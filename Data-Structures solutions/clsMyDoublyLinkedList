#pragma once
#include <iostream>


using namespace std;


template<class T>
class  clsDblLinkedList
{

protected:
	int _Size;


public:

	class Node {

	public:
		T value;
		Node* next;
		Node* prev;


	};

	Node* head;

	clsDblLinkedList() {
		head = new Node();
		head = NULL;
		_Size = 0;
	}

	int Size() {
	
		return _Size;
	
	}

	bool isEmpty() {
	
		return _Size == 0 ? true : false;
	
	}

	void Clear() {
	
		while (_Size > 0)
		{
			DeleteFirstNode();
		}
	
	}

	void Reverse() {
		//My Solution:
			/*if (head == NULL || head->next == NULL)
				return;
			int SizeBeforeReversing = _Size;
			Node* current = head->next;
			Node* temp = current;
			while (current != NULL)
			{
				InsertAtBegenning(current->value);
				temp = current->next;
				if (current->next != NULL)
					current->next->prev = current->prev;
				current->prev->next = current->next;
				delete current;
				current = temp;
			}
			_Size = SizeBeforeReversing;*/

			///////////////////////////////////////////////////////////////////////
			//   Mr.Mohammed solution
			// 
			// 
				Node* current = head;
				Node* temp = nullptr;
				while (current != nullptr)
				{
					//Swap (next_prev).
					temp = current->prev;
					current->prev = current->next;
					current->next = temp;
					current = current->prev;
				}
				if (temp != nullptr)
				{
					head = temp->prev;
				}


		//حل احد الزملاء في التعليقات
		/*Node* Temp = head;
		clsDblLinkedList <int>NewLinkedList;
		while (Temp != NULL)
		{
			NewLinkedList.InsertAtBegenning(Temp->value);
			Temp = Temp->next;

		}
		Clear();
		*this = NewLinkedList;*/

	}

	Node* GetNode(short Index) {
	
		if (Index > _Size - 1 || Index < 0)
		{
			return NULL;
		}

		int counter = 0;
		Node* current = head;
		while (current != NULL && current->next != NULL)
		{
			if (counter == Index)
				break;

			current = current->next;
			counter++;
		}
		return current;
	
	}

	T GetItem(short Index) {
	
		Node* ItemNode = GetNode(Index);

		if (ItemNode == NULL)
			return NULL;
		else
			return ItemNode->value;
	
	}

	bool UpdateItem(short Index, T UpdatedValue) {

		Node* NodeItem = GetNode(Index);

		if (NodeItem != NULL)
		{
			NodeItem->value = UpdatedValue;
			return true;
		}
		return false;
	}

	void InsertAtBegenning(T value) {

		Node* new_node = new Node();

		new_node->value = value;
		new_node->next = head;
		new_node->prev = NULL;

		if (head != NULL)
			head->prev = new_node;

		head = new_node;
		_Size++;


	}

	void PrintNodeDetails(Node *current) {

		if (current->prev != NULL)
			cout << current->prev->value;
		else
			cout << "NULL";
		cout << "<--> " << current->value << " <--> ";
		if (current->next != NULL)
			cout << current->next->value << endl;
		else
			cout << "NULL\n";

	}


	void PrintListDetails() {


		if (head == NULL)
		{
			cout << "\nNULL\n";
			return;
		}
		Node* current = head;
		while (current != NULL)
		{
			PrintNodeDetails(current);
			current = current->next;
		}

	}


	void PrintList() {

		if (head == NULL)
		{
			cout << "\nNULL\n";
			return;
		}

		cout << "\nNULL <--> ";

		Node* current = head;
		while (current != NULL)
		{

			cout << current->value << " <--> ";
			current = current->next;
		}
		cout << "NULL\n";
	}

	Node* Find( T Value) {
		Node* current = head;
		while (current != NULL)
		{
			if (current->value == Value)
				return current;
			current = current->next;
		}
		return NULL;


	}

	void InsertAfter(Node* Prev_node, T val) {

		if (Prev_node == NULL)
		{
			cout << "\nPrevios Node connot be Null\n";
			return;
		}

		Node* new_node = new Node();
		new_node->value = val;
		new_node->next = Prev_node->next;

		if (new_node->next != NULL)
			new_node->next->prev = new_node;

		new_node->prev = Prev_node;
		Prev_node->next = new_node;
		_Size++;


	}

	bool InsertAfter(short Index, T UpdatedValue) {

		Node* prev_node = GetNode(Index);
		if (prev_node != NULL)
		{
			InsertAfter(prev_node, UpdatedValue);
			return true;
		}
		return false;
	}

	void InsertAtEnd(T val) {


		Node* new_node = new Node();
		new_node->value = val;
		new_node->next = NULL;
		new_node->prev = NULL;
		if (head == NULL)
		{
			head = new_node;
			_Size++;
			return;
		}
		Node* LastNode = head;
		while (LastNode->next != NULL)
		{
			LastNode = LastNode->next;
		}

		LastNode->next = new_node;
		new_node->prev = LastNode;
		_Size++;

	}

	void DeleteNode(Node* &delete_node) {


		if (head == NULL || delete_node == NULL)
		{
			return;
		}

		if (head == delete_node)
		{
			head = head->next;
			delete delete_node;
			_Size--;
			if (head != NULL)
				head->prev = NULL;
			return;
		}

		if (delete_node->next != NULL)
		{
			delete_node->next->prev = delete_node->prev;
		}
		if (delete_node->prev != NULL)
		{
			delete_node->prev->next = delete_node->next;
		}
		delete delete_node;
		_Size--;


	}

	void DeleteFirstNode() {

		if (head == NULL)
		{
			return;
		}
		Node* First_Node = head;
		head = head->next;
		if (head != NULL)
			head->prev = NULL;
		delete First_Node;
		_Size--;

	}

	void DeleteLastNode() {

		Node* Last_Node = head;


		if (head == NULL)
		{
			cout << "\nhead is empty\n";
			return;
		}
		if (head->next == NULL)
		{
			head = NULL;
			delete Last_Node;
			_Size--;
			return;
		}

		while (Last_Node->next != NULL)
		{
			Last_Node = Last_Node->next;
		}
		Last_Node->prev->next = NULL;
		delete Last_Node;
		_Size--;


	}


};

